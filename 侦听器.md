è®¡ç®—å±æ€§å…è®¸æˆ‘ä»¬å£°æ˜æ€§åœ°è®¡ç®—è¡ç”Ÿå€¼ã€‚ç„¶è€Œåœ¨æœ‰äº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦åœ¨çŠ¶æ€å˜åŒ–æ—¶è‡ªåŠ¨æ‰§è¡Œä¸€äº›é€»è¾‘ï¼Œè¿™æ—¶ç”¨è®¡ç®—å±æ€§å°±ä¸å¤ªåˆé€‚äº†ï¼Œåº”è¯¥ä½¿ç”¨ä¾¦å¬å™¨å®Œæˆä¸Šè¿°éœ€æ±‚ã€‚

åœ¨Vue 3ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Â [`watch`Â é€‰é¡¹](https://cn.vuejs.org/api/options-state.html#watch)åœ¨æ¯æ¬¡å“åº”å¼å±æ€§å‘ç”Ÿå˜åŒ–æ—¶è§¦å‘ä¸€ä¸ªå‡½æ•°ã€‚

```ts
export default {
  data() {
    return {
      question: '',
      answer: 'Questions usually contain a question mark. ;-)'
    }
  },
  watch: {
    // æ¯å½“ question æ”¹å˜æ—¶ï¼Œè¿™ä¸ªå‡½æ•°å°±ä¼šæ‰§è¡Œ
    question(newQuestion, oldQuestion) {
      if (newQuestion.includes('?')) {
        this.getAnswer()
      }
    }
  },
  methods: {
    async getAnswer() {
      this.answer = 'Thinking...'
      try {
        const res = await fetch('https://yesno.wtf/api')
        this.answer = (await res.json()).answer
      } catch (error) {
        this.answer = 'Error! Could not reach the API. ' + error
      }
    }
  }
}
```

```html
<p>
  Ask a yes/no question:
  <input v-model="question" />
</p>
<p>{{ answer }}</p>
```

ä¹Ÿå¯ä»¥é€šè¿‡ $watch API å»åˆ›å»ºä¸€ä¸ªä¾¦å¬å™¨

```ts
const unwatch = this.$watch('foo', callback)

// ...å½“è¯¥ä¾¦å¬å™¨ä¸å†éœ€è¦æ—¶
unwatch()
```

é€šè¿‡ `$watch()`Â APIåˆ›å»ºçš„ä¾¦å¬å™¨ä¼šè¿”å›ä¸€ä¸ª unwatch å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æ‰§è¡Œå®ƒæ¥åœæ­¢ watcher å¯¹æ•°æ®çš„ä¾¦å¬ï¼›

ç”¨Â `watch`Â é€‰é¡¹æˆ–è€…Â `$watch()`Â å®ä¾‹æ–¹æ³•å£°æ˜çš„ä¾¦å¬å™¨ï¼Œä¼šåœ¨å®¿ä¸»ç»„ä»¶å¸è½½æ—¶è‡ªåŠ¨åœæ­¢ã€‚

## watch API çš„ç”¨æ³•

1. watch API å¯ä»¥ä¾¦å¬ä¸€ä¸ª getter å‡½æ•°ï¼Œä½†æ˜¯å®ƒå¿…é¡»è¿”å›ä¸€ä¸ªå“åº”å¼å¯¹è±¡ï¼Œå½“è¯¥å“åº”å¼å¯¹è±¡æ›´æ–°åï¼Œä¼šæ‰§è¡Œå¯¹åº”çš„å›è°ƒå‡½æ•°ã€‚
   
   ```ts
   import { reactive, watch } from 'vue' 
   
   const state = reactive({ count: 0 }) 
   
   watch(() => state.count, (count, prevCount) => { 
   
     // å½“ state.count æ›´æ–°ï¼Œä¼šè§¦å‘æ­¤å›è°ƒå‡½æ•° 
   
   }) 
   
   ```

2. watch API ä¹Ÿå¯ä»¥ç›´æ¥**ä¾¦å¬ä¸€ä¸ªå“åº”å¼å¯¹è±¡**ï¼Œå½“å“åº”å¼å¯¹è±¡æ›´æ–°åï¼Œä¼šæ‰§è¡Œå¯¹åº”çš„å›è°ƒå‡½æ•°ã€‚
   
   ```ts
   import { ref, watch } from 'vue' 
   
   const count = ref(0) 
   
   watch(count, (count, prevCount) => { 
   
     // å½“ count.value æ›´æ–°ï¼Œä¼šè§¦å‘æ­¤å›è°ƒå‡½æ•° 
   
   }) 
   
   ```

3. watch API è¿˜å¯ä»¥ç›´æ¥**ä¾¦å¬å¤šä¸ªå“åº”å¼å¯¹è±¡**ï¼Œä»»æ„ä¸€ä¸ªå“åº”å¼å¯¹è±¡æ›´æ–°åï¼Œå°±ä¼šæ‰§è¡Œå¯¹åº”çš„å›è°ƒå‡½æ•°ã€‚
   
   ```ts
   import { ref, watch } from 'vue' 
   const count = ref(0) 
   const count2 = ref(1) 
   watch([count, count2], ([count, count2], [prevCount, prevCount2]) => { 
     // å½“ count.value æˆ–è€… count2.value æ›´æ–°ï¼Œä¼šè§¦å‘æ­¤å›è°ƒå‡½æ•° 
   }) 
   ```

### watch API å®ç°åŸç†

æˆ‘ä»¬å…ˆçœ‹ä¸‹ watch API çš„å…·ä½“å®ç°ï¼š

```ts
function watch<T = any, Immediate extends Readonly<boolean> = false>(
  source: T | WatchSource<T>,
  cb: any,
  options?: WatchOptions<Immediate>
): WatchStopHandle {
  if (__DEV__ && !isFunction(cb)) {
    warn(
      `\`watch(fn, options?)\` signature has been moved to a separate API. ` +
        `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
        `supports \`watch(source, cb, options?) signature.`
    )
  }
  return doWatch(source as any, cb, options)
}

```

watch å‡½æ•°æ‹¥æœ‰ä¸‰ä¸ªå‚æ•°ï¼Œå…¶ä¸­ source è¡¨ç¤ºè§‚å¯Ÿçš„æ•°æ®æºï¼Œcb è¡¨ç¤ºæ•°æ®å˜åŒ–åæ‰§è¡Œçš„å›è°ƒå‡½æ•°ï¼Œ options è¡¨ç¤ºä¸€äº›é…ç½®é€‰é¡¹ã€‚

watch å‡½æ•°å†…éƒ¨è°ƒç”¨äº† doWatch å‡½æ•°ï¼Œè°ƒç”¨å‰ä¼šåœ¨éç”Ÿäº§ç¯å¢ƒä¸‹åˆ¤æ–­ç¬¬äºŒä¸ªå‚æ•° cb æ˜¯ä¸æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå¦‚æœä¸æ˜¯åˆ™ä¼šæŠ¥è­¦å‘Šä»¥å‘Šè¯‰ç”¨æˆ·åº”è¯¥ä½¿ç”¨ watchEffect(fn, options) APIï¼ŒwatchEffect API ä¹Ÿæ˜¯ä¾¦å¬å™¨ç›¸å…³çš„ APIï¼Œç¨åæˆ‘ä»¬ä¼šè¯¦ç»†ä»‹ç»ã€‚

### doWatch



```ts
function doWatch(
  source: WatchSource | WatchSource[] | WatchEffect | object,
  cb: WatchCallback | null,
  { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ
): WatchStopHandle {
  // ... çœç•¥
  
  // source ä¸åˆæ³•çš„æ—¶å€™ä¼šå‘å‡ºè­¦å‘Š
  const warnInvalidSource = (s: unknown) => {
    warn(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, ` +
        `a reactive object, or an array of these types.`
    )
  }

  // å½“å‰ç»„ä»¶å®ä¾‹ 
  const instance =
    getCurrentScope() === currentInstance?.scope ? currentInstance : null
  // const instance = currentInstance
  let getter: () => any
  // å¼ºåˆ¶æ›´æ–°
  let forceTrigger = false
  let isMultiSource = false

  if (isRef(source)) {
    getter = () => source.value
    forceTrigger = isShallow(source)
  } else if (isReactive(source)) {
    getter = () => source
    deep = true
  } else if (isArray(source)) {
    isMultiSource = true
    forceTrigger = source.some(s => isReactive(s) || isShallow(s))
    getter = () =>
      source.map(s => {
        if (isRef(s)) {
          return s.value
        } else if (isReactive(s)) {
          return traverse(s)
        } else if (isFunction(s)) {
          return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)
        } else {
          __DEV__ && warnInvalidSource(s)
        }
      })
  } else if (isFunction(source)) {
    if (cb) {
      // watch API å¸¦æœ‰ cb
      getter = () =>
        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)
    } else {
      // no cb -> simple effect
      // watchEffect çš„é€»è¾‘
      // .... çœç•¥
    }
  } else {
    getter = NOOP
    __DEV__ && warnInvalidSource(source)
  }

  // 2.x array mutation watch compat
  if (__COMPAT__ && cb && !deep) {
    const baseGetter = getter
    getter = () => {
      const val = baseGetter()
      if (
        isArray(val) &&
        checkCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance)
      ) {
        traverse(val)
      }
      return val
    }
  }

  if (cb && deep) {
    const baseGetter = getter
    getter = () => traverse(baseGetter())
  }

  let cleanup: () => void
  // æ³¨å†Œæ— æ•ˆå›è°ƒå‡½æ•°
  let onCleanup: OnCleanup = (fn: () => void) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)
    }
  }
  // çœç•¥ssrä»£ç    

  // æ—§å€¼åˆå§‹å€¼
  let oldValue: any = isMultiSource
    ? new Array((source as []).length).fill(INITIAL_WATCHER_VALUE)
    : INITIAL_WATCHER_VALUE
  // å¼‚æ­¥ä»»åŠ¡
  const job: SchedulerJob = () => {
    // effect éæ¿€æ´»ï¼Œç›´æ¥è¿”å›
    if (!effect.active) {
      return
    }
    if (cb) {
      // watch(source, cb)
      // æ±‚å¾—æ–°å€¼
      const newValue = effect.run()
      if (
        deep ||
        forceTrigger ||
        (isMultiSource
          ? (newValue as any[]).some((v, i) => hasChanged(v, oldValue[i]))
          : hasChanged(newValue, oldValue)) ||
        (__COMPAT__ &&
          isArray(newValue) &&
          isCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance))
      ) {
        // cleanup before running cb again
        // æ‰§è¡Œæ¸…ç†å‡½æ•°
        if (cleanup) {
          cleanup()
        }
        // æ‰§è¡Œå›è°ƒå‡½æ•° cb
        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          // ç¬¬ä¸€æ¬¡æ›´æ”¹æ—¶ï¼Œä¼ é€’çš„æ—§å€¼ä¸º undefined
          oldValue === INITIAL_WATCHER_VALUE
            ? undefined
            : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE
            ? []
            : oldValue,
          onCleanup
        ])
        // æ›´æ–°æ—§å€¼
        oldValue = newValue
      }
    } else {
      // watchEffect
      effect.run()
    }
  }

  // important: mark the job as a watcher callback so that scheduler knows
  // it is allowed to self-trigger (#1727)
  // å…è®¸è§¦å‘è‡ªèº«
  job.allowRecurse = !!cb

  let scheduler: EffectScheduler
  if (flush === 'sync') {
    // åŒæ­¥
    scheduler = job as any // the scheduler function gets called directly
  } else if (flush === 'post') {
    // è¿›å…¥ä¸€æ­¥é˜Ÿåˆ—ï¼Œç»„ä»¶æ›´æ–°åæ‰§è¡Œ
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)
  } else {
    // default: 'pre'
    // é»˜è®¤é€‰é¡¹ï¼Œåœ¨ç»„ä»¶æ›´æ–°å‰æ‰§è¡Œ
    job.pre = true
    if (instance) job.id = instance.uid
    scheduler = () => queueJob(job)
  }

  // åˆ›å»º effect å®ä¾‹
  const effect = new ReactiveEffect(getter, scheduler)

  if (__DEV__) {
    effect.onTrack = onTrack
    effect.onTrigger = onTrigger
  }

  // åˆæ¬¡æ‰§è¡Œ
  if (cb) {
    if (immediate) {
      job()
    } else {
       // æ±‚æ—§å€¼
      oldValue = effect.run()
    }
  } else if (flush === 'post') {
    queuePostRenderEffect(
      effect.run.bind(effect),
      instance && instance.suspense
    )
  } else {
    effect.run()
  }

  const unwatch = () => {
    effect.stop()
    if (instance && instance.scope) {
      remove(instance.scope.effects!, effect)
    }
  }

  if (__SSR__ && ssrCleanup) ssrCleanup.push(unwatch)
  return unwatch
}
```

doWatchå¯ä»¥åˆ†æˆå‡ ä¸ªæ­¥éª¤ï¼š

1. #### æ ‡å‡†åŒ– source
   
   å‰é¢è¯´è¿‡ï¼Œsource å¯ä»¥æ˜¯ getter å‡½æ•°ï¼Œä¹Ÿå¯ä»¥æ˜¯å“åº”å¼å¯¹è±¡ç”šè‡³æ˜¯å“åº”å¼å¯¹è±¡æ•°ç»„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ ‡å‡†åŒ– sourceï¼Œè¿™æ˜¯**æ ‡å‡†åŒ– source çš„æµç¨‹**
   
   source æ ‡å‡†åŒ–ä¸»è¦æ˜¯**æ ¹æ® source çš„ç±»å‹ï¼Œå°†å…¶å˜æˆÂ æ ‡å‡†åŒ–åçš„ getter å‡½æ•°ã€‚** å…·ä½“æ¥è¯´ï¼š
   
   1. å¦‚æœ source æ˜¯ ref å¯¹è±¡ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªè®¿é—® source.value çš„ getter å‡½æ•°;
   
   2. å¦‚æœ source æ˜¯ reactive å¯¹è±¡ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªè®¿é—® source çš„ getter å‡½æ•°ï¼Œå¹¶è®¾ç½® deep ä¸º true;
   
   3. å¦‚æœ source æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œåˆ™ä¼šè¿›ä¸€æ­¥åˆ¤æ–­ç¬¬äºŒä¸ªå‚æ•° cb æ˜¯å¦å­˜åœ¨ï¼Œå¯¹äº watch API æ¥è¯´ï¼Œcb æ˜¯ä¸€å®šå­˜åœ¨ä¸”æ˜¯ä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œgetter å°±æ˜¯ä¸€ä¸ªç®€å•çš„å¯¹ source å‡½æ•°å°è£…çš„å‡½æ•°ã€‚
   
   4. å¦‚æœ source æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œç”Ÿæˆçš„ getter å‡½æ•°å†…éƒ¨ä¼šé€šè¿‡ source.map å‡½æ•°æ˜ å°„å¤„ä¸€ä¸ªæ–°çš„æ•°ç»„ï¼Œå®ƒä¼šåˆ¤æ–­æ¯ä¸ªæ•°ç»„å…ƒç´ çš„ç±»å‹ï¼Œæ˜ å°„è§„åˆ™ä¸å‰é¢çš„ source è§„åˆ™ç±»ä¼¼
   
   5. å¦‚æœ source ä¸æ»¡è¶³ä¸Šè¿°æ¡ä»¶ï¼Œåˆ™åœ¨éç”Ÿäº§ç¯å¢ƒä¸‹å‘å‡ºè­¦å‘Šï¼Œæç¤º source ç±»å‹ä¸åˆæ³•ã€‚
   
   æœ€åæˆ‘ä»¬æ¥å…³æ³¨ä¸€ä¸‹ deep ä¸º true çš„æƒ…å†µã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬ä¼šå‘ç°ç”Ÿæˆçš„ getter å‡½æ•°ä¼šè¢« traverse å‡½æ•°åŒ…è£…ä¸€å±‚ã€‚traverse å‡½æ•°çš„å®ç°å¾ˆç®€å•ï¼Œå³é€šè¿‡é€’å½’çš„æ–¹å¼è®¿é—® value çš„æ¯ä¸€ä¸ªå­å±æ€§ã€‚é‚£ä¹ˆï¼Œä¸ºä»€ä¹ˆè¦é€’å½’è®¿é—®æ¯ä¸€ä¸ªå­å±æ€§å‘¢ï¼Ÿ
   
   å…¶å® deep å±äº watcher çš„ä¸€ä¸ªé…ç½®é€‰é¡¹ï¼ŒVue.js 2.x ä¹Ÿæ”¯æŒï¼Œè¡¨é¢å«ä¹‰æ˜¯**æ·±åº¦ä¾¦å¬ï¼Œå®é™…ä¸Šæ˜¯é€šè¿‡éå†å¯¹è±¡çš„æ¯ä¸€ä¸ªå­å±æ€§æ¥å®ç°**ã€‚ä¸¾ä¸ªä¾‹å­ä½ å°±æ˜ç™½äº†ï¼š
   
   ```ts
   import { reactive, watch } from 'vue' 
   const state = reactive({ 
     count: { 
       a: { 
         b: 1 
       } 
     } 
   }) 
   watch(state.count, (count, prevCount) => { 
     console.log(count) 
   }) 
   state.count.a.b = 2  
   ```
   
   è¿™é‡Œï¼Œæˆ‘ä»¬åˆ©ç”¨ reactive API åˆ›å»ºäº†ä¸€ä¸ªåµŒå¥—å±‚çº§è¾ƒæ·±çš„å“åº”å¼å¯¹è±¡ stateï¼Œç„¶åå†è°ƒç”¨ watch API ä¾¦å¬ state.count çš„å˜åŒ–ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬ä¿®æ”¹å†…éƒ¨å±æ€§ state.count.a.b çš„å€¼ï¼Œä½ ä¼šå‘ç° watcher çš„å›è°ƒå‡½æ•°æ‰§è¡Œäº†ï¼Œä¸ºä»€ä¹ˆä¼šæ‰§è¡Œå‘¢ï¼Ÿ
   
   å½“æˆ‘ä»¬æ‰§è¡Œ watch å‡½æ•°çš„æ—¶å€™ï¼Œæˆ‘ä»¬çŸ¥é“å¦‚æœä¾¦å¬çš„æ˜¯ä¸€ä¸ª reactive å¯¹è±¡ï¼Œé‚£ä¹ˆå†…éƒ¨ä¼šè®¾ç½® deep ä¸º trueï¼Œç„¶åæ‰§è¡Œ traverse å»é€’å½’è®¿é—®å¯¹è±¡æ·±å±‚å­å±æ€§ï¼Œè¿™ä¸ªæ—¶å€™å°±ä¼šè®¿é—® state.count.a.b è§¦å‘ä¾èµ–æ”¶é›†ï¼Œè¿™é‡Œæ”¶é›†çš„ä¾èµ–æ˜¯ watcher å†…éƒ¨åˆ›å»ºçš„ effect runnerã€‚å› æ­¤ï¼Œå½“æˆ‘ä»¬å†å»ä¿®æ”¹ state.count.a.b çš„æ—¶å€™ï¼Œå°±ä¼šé€šçŸ¥è¿™ä¸ª effect ï¼Œæ‰€ä»¥æœ€ç»ˆä¼šæ‰§è¡Œ watcher çš„å›è°ƒå‡½æ•°ã€‚
   
   å½“æˆ‘ä»¬ä¾¦å¬ä¸€ä¸ªé€šè¿‡ reactive API åˆ›å»ºçš„å“åº”å¼å¯¹è±¡æ—¶ï¼Œå†…éƒ¨ä¼šæ‰§è¡Œ traverse å‡½æ•°ï¼Œå¦‚æœè¿™ä¸ªå¯¹è±¡éå¸¸å¤æ‚ï¼Œæ¯”å¦‚åµŒå¥—å±‚çº§å¾ˆæ·±ï¼Œé‚£ä¹ˆé€’å½’ traverse å°±ä¼šæœ‰ä¸€å®šçš„æ€§èƒ½è€—æ—¶ã€‚å› æ­¤å¦‚æœæˆ‘ä»¬éœ€è¦ä¾¦å¬è¿™ä¸ªå¤æ‚å“åº”å¼å¯¹è±¡å†…éƒ¨çš„æŸä¸ªå…·ä½“å±æ€§ï¼Œå°±å¯ä»¥æƒ³åŠæ³•å‡å°‘ traverse å¸¦æ¥çš„æ€§èƒ½æŸè€—ã€‚
   
   æ¯”å¦‚åˆšæ‰çš„ä¾‹å­ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç›´æ¥ä¾¦å¬ state.count.a.b çš„å˜åŒ–ï¼š
   
   ```ts
   watch(state.count, (count, prevCount) => { 
     console.log(count) 
   }) 
   state.count.a.b = 2  
   ```
   
   è¿™æ ·å°±å¯ä»¥å‡å°‘å†…éƒ¨æ‰§è¡Œ traverse çš„æ¬¡æ•°ã€‚ä½ å¯èƒ½ä¼šé—®ï¼Œç›´æ¥ä¾¦å¬ state.count.a.b å¯ä»¥å—ï¼Ÿç­”æ¡ˆæ˜¯ä¸è¡Œï¼Œå› ä¸º state.count.a.b å·²ç»æ˜¯ä¸€ä¸ªåŸºç¡€æ•°å­—ç±»å‹äº†ï¼Œä¸ç¬¦åˆ source è¦æ±‚çš„å‚æ•°ç±»å‹ï¼Œæ‰€ä»¥ä¼šåœ¨éç”Ÿäº§ç¯å¢ƒä¸‹æŠ¥è­¦å‘Šã€‚
   
   é‚£ä¹ˆæœ‰æ²¡æœ‰åŠæ³•ä¼˜åŒ–ä½¿å¾— traverse ä¸æ‰§è¡Œå‘¢ï¼Ÿç­”æ¡ˆæ˜¯å¯ä»¥çš„ã€‚æˆ‘ä»¬å¯ä»¥ä¾¦å¬ä¸€ä¸ª getter å‡½æ•°ï¼š
   
   ```ts
   watch(() => state.count.a.b, (count, oldVal) => { 
     console.log(count) 
   }) 
   state.count.a.b = 2 
   ```
   
   è¿™æ ·å‡½æ•°å†…éƒ¨ä¼šè®¿é—®å¹¶è¿”å› state.count.a.bï¼Œä¸€æ¬¡ traverse éƒ½ä¸ä¼šæ‰§è¡Œå¹¶ä¸”ä¾ç„¶å¯ä»¥ä¾¦å¬åˆ°å®ƒçš„å˜åŒ–ä»è€Œæ‰§è¡Œ watcher çš„å›è°ƒå‡½æ•°ã€‚

2. **åˆ›å»º job**
   
   è¿™é‡Œé‡ç‚¹å…³æ³¨ job å‡½æ•°çš„å®ç°
   
   å¦‚æœ cb å‡½æ•°å­˜åœ¨ï¼Œä¼šå…ˆæ‰§è¡Œ effect.run å‡½æ•°æ±‚å¾—æ–°å€¼ï¼Œè¿™é‡Œå®é™…ä¸Šå°±æ˜¯æ‰§è¡Œå‰é¢åˆ›å»ºçš„ getter å‡½æ•°æ±‚æ–°å€¼ã€‚
   
   ç„¶åè¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœæ˜¯ deep æˆ–è€… forceTrigger å¼ºåˆ¶æ›´æ–°,åˆæˆ–è€…æ˜¯æ–°æ—§å€¼å‘ç”Ÿäº†å˜åŒ–ï¼Œåˆ™æ‰§è¡Œå›è°ƒå‡½æ•°cbï¼Œä¼ å…¥å‚æ•° newValue å’Œ oldValueã€‚æ³¨æ„ï¼Œç¬¬ä¸€æ¬¡æ‰§è¡Œçš„æ—¶å€™æ—§å€¼çš„åˆå§‹å€¼æ˜¯ç©ºæ•°ç»„æˆ–è€… undefinedã€‚æ‰§è¡Œå®Œå›è°ƒå‡½æ•° cb åï¼ŒæŠŠæ—§å€¼ oldValue å†æ›´æ–°ä¸º newValueï¼Œè¿™æ˜¯ä¸ºäº†ä¸‹ä¸€æ¬¡çš„æ¯”å¯¹ã€‚

3. **åˆ›å»º scheduler**
   
   scheduler çš„ä½œç”¨æ˜¯æ ¹æ®æŸç§è°ƒåº¦çš„æ–¹å¼å»æ‰§è¡ŒæŸç§å‡½æ•°ï¼Œåœ¨ watch API ä¸­ï¼Œä¸»è¦å½±å“åˆ°çš„æ˜¯å›è°ƒå‡½æ•°çš„æ‰§è¡Œæ–¹å¼ã€‚
   
   Watch API çš„å‚æ•°é™¤äº† source å’Œ cbï¼Œè¿˜æ”¯æŒç¬¬ä¸‰ä¸ªå‚æ•° optionsï¼Œä¸åŒçš„é…ç½®å†³å®šäº† watcher çš„ä¸åŒè¡Œä¸ºã€‚å‰é¢æˆ‘ä»¬ä¹Ÿåˆ†æäº† deep ä¸º true çš„æƒ…å†µï¼Œé™¤äº† source ä¸º reactive å¯¹è±¡æ—¶ä¼šé»˜è®¤æŠŠ deep è®¾ç½®ä¸º trueï¼Œä½ ä¹Ÿå¯ä»¥ä¸»åŠ¨ä¼ å…¥ç¬¬ä¸‰ä¸ªå‚æ•°ï¼ŒæŠŠ deep è®¾ç½®ä¸º trueã€‚
   
   è¿™é‡Œï¼Œscheduler çš„åˆ›å»ºé€»è¾‘å—åˆ°äº†ç¬¬ä¸‰ä¸ªå‚æ•° Options ä¸­çš„ flush å±æ€§å€¼çš„å½±å“ï¼Œä¸åŒçš„ flush å†³å®šäº† watcher çš„æ‰§è¡Œæ—¶æœºã€‚
   
   - å½“ flush ä¸º sync çš„æ—¶å€™ï¼Œè¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ªåŒæ­¥ watcherï¼Œå³å½“æ•°æ®å˜åŒ–æ—¶åŒæ­¥æ‰§è¡Œå›è°ƒå‡½æ•°ã€‚
   
   - å½“ flush ä¸º post æ—¶ï¼Œå›è°ƒå‡½æ•°é€šè¿‡ queuePostRenderEffect çš„æ–¹å¼åœ¨ç»„ä»¶æ›´æ–°ä¹‹åæ‰§è¡Œ
   
   - å¦‚æœæ²¡è®¾ç½® flushï¼Œå›è°ƒå‡½æ•°é€šè¿‡ queueJob çš„æ–¹å¼åœ¨ç»„ä»¶æ›´æ–°ä¹‹å‰æ‰§è¡Œ

4. **åˆ›å»º Effect** 
   
   è¿™æ®µé€»è¾‘æ˜¯æ•´ä¸ª watcher å®ç°çš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œ å³åˆ›å»ºäº† effect å¯¹è±¡ï¼Œ å¹¶æŠŠæ ‡å‡†åŒ–çš„ getter å‡½æ•°å’Œ scheduler è°ƒåº¦å‡½æ•°ä½œä¸ºå‚æ•°ä¼ å…¥
   
   * effect.runçš„æ‰§è¡Œ
     
     å½“å›è°ƒå‡½æ•° cb å­˜åœ¨ä¸” immediate ä¸º falseæ—¶ï¼Œä¼šé¦–æ¬¡æ‰§è¡Œ effect.run å‡½æ•°æ±‚æ—§å€¼ï¼Œå‡½æ•°å†…éƒ¨æ‰§è¡Œ getter å‡½æ•°ï¼Œè®¿é—®å“åº”å¼æ•°æ®å¹¶åšä¾èµ–æ”¶é›†ã€‚æ³¨æ„ï¼Œæ­¤æ—¶ activeEffect å°±æ˜¯ watcher å†…éƒ¨åˆ›å»ºçš„ effect å¯¹è±¡ï¼Œè¿™æ ·åœ¨åé¢æ›´æ–°å“åº”å¼æ•°æ®æ—¶ï¼Œå°±å¯ä»¥è§¦å‘ effect å¯¹è±¡çš„ scheduler å‡½æ•°ï¼Œä»¥ä¸€ç§è°ƒåº¦æ–¹å¼æ¥æ‰§è¡Œ job å‡½æ•°
   
   * é…ç½®äº† immediate çš„æƒ…å†µ
     
     å½“æˆ‘ä»¬é…ç½®äº† immediate ï¼Œåˆ›å»ºå®Œ watcher ä¼šç«‹å³æ‰§è¡Œ job å‡½æ•°ï¼Œæ­¤æ—¶ oldValue è¿˜æ˜¯åˆå§‹å€¼ï¼Œåœ¨ job æ‰§è¡Œæ—¶ä¹Ÿä¼šæ‰§è¡Œ effect.run,è¿›è€Œæ‰§è¡Œå‰é¢çš„ getter å‡½æ•°åšä¾èµ–æ”¶é›†ï¼Œå¹¶æ±‚å¾—æ–°å€¼

5. **è¿”å›é”€æ¯å‡½æ•°**
   
   æœ€åä¼šè¿”å›é”€æ¯å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨å®ƒæ¥åœæ­¢ watcher å¯¹æ•°æ®çš„ä¾¦å¬ã€‚
   
   é”€æ¯å‡½æ•°å†…éƒ¨ä¼šæ‰§è¡Œ effect.stop å‡½æ•°è®© effect å¤±æ´»ï¼Œå¹¶æ¸…ç† effect çš„ç›¸å…³ä¾èµ–ï¼Œè¿™æ ·å°±å¯ä»¥åœæ­¢å¯¹æ•°æ®çš„ä¾¦å¬ã€‚åŒæ—¶ï¼Œå¦‚æœæ˜¯åœ¨ç»„ä»¶ä¸­æ³¨å†Œçš„ watcher, ä¹Ÿä¼šç§»é™¤ç»„ä»¶ effects å¯¹è¿™ä¸ªeffect çš„å¼•ç”¨ã€‚
   
   

## å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—çš„è®¾è®¡

å›è°ƒå‡½æ•°æ˜¯ä»¥ä¸€ç§è°ƒåº¦çš„æ–¹å¼æ‰§è¡Œçš„ï¼Œç‰¹åˆ«æ˜¯å½“ flush ä¸æ˜¯ sync æ—¶ï¼Œå®ƒä¼šæŠŠå›è°ƒå‡½æ•°æ‰§è¡Œçš„ä»»åŠ¡æ¨åˆ°ä¸€ä¸ªå¼‚æ­¥é˜Ÿåˆ—ä¸­æ‰§è¡Œã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±æ¥åˆ†æå¼‚æ­¥æ‰§è¡Œé˜Ÿåˆ—çš„è®¾è®¡ã€‚åˆ†æä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥æ€è€ƒä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆä¼šéœ€è¦å¼‚æ­¥é˜Ÿåˆ—ï¼Ÿ

æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸ªğŸŒ°

```ts
import { reactive, watch } from 'vue' 
const state = reactive({ count: 0 }) 
watch(() => state.count, (count, prevCount) => { 
  console.log(count) 
}) 
state.count++ 
state.count++ 
state.count++ 
```

è¿™é‡Œï¼Œæˆ‘ä»¬ä¿®æ”¹äº†ä¸‰æ¬¡ state.countï¼Œé‚£ä¹ˆ watcher çš„å›è°ƒå‡½æ•°ä¼šæ‰§è¡Œä¸‰æ¬¡å—ï¼Ÿ

ç­”æ¡ˆæ˜¯ä¸ä¼šï¼Œå®é™…ä¸Šåªè¾“å‡ºäº†ä¸€æ¬¡ count çš„å€¼ï¼Œä¹Ÿå°±æ˜¯æœ€ç»ˆè®¡ç®—çš„å€¼ 3ã€‚è¿™åœ¨å¤§å¤šæ•°åœºæ™¯ä¸‹éƒ½æ˜¯ç¬¦åˆé¢„æœŸçš„ï¼Œå› ä¸ºåœ¨ä¸€ä¸ª Tickï¼ˆå®ä»»åŠ¡æ‰§è¡Œçš„ç”Ÿå‘½å‘¨æœŸï¼‰å†…ï¼Œå³ä½¿å¤šæ¬¡ä¿®æ”¹ä¾¦å¬çš„å€¼ï¼Œå®ƒçš„å›è°ƒå‡½æ•°ä¹Ÿåªæ‰§è¡Œä¸€æ¬¡ã€‚

> **çŸ¥è¯†å»¶ä¼¸**  
> ç»„ä»¶çš„æ›´æ–°è¿‡ç¨‹æ˜¯å¼‚æ­¥çš„ï¼Œæˆ‘ä»¬çŸ¥é“ä¿®æ”¹æ¨¡æ¿ä¸­å¼•ç”¨çš„å“åº”å¼å¯¹è±¡çš„å€¼æ—¶ï¼Œä¼šè§¦å‘ç»„ä»¶çš„é‡æ–°æ¸²æŸ“ï¼Œä½†æ˜¯åœ¨ä¸€ä¸ª Tick å†…ï¼Œå³ä½¿ä½ å¤šæ¬¡ä¿®æ”¹å¤šä¸ªå“åº”å¼å¯¹è±¡çš„å€¼ï¼Œç»„ä»¶çš„é‡æ–°æ¸²æŸ“ä¹Ÿåªæ‰§è¡Œä¸€æ¬¡ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœæ¯æ¬¡æ›´æ–°æ•°æ®éƒ½è§¦å‘ç»„ä»¶é‡æ–°æ¸²æŸ“ï¼Œé‚£ä¹ˆé‡æ–°æ¸²æŸ“çš„æ¬¡æ•°å’Œä»£ä»·éƒ½å¤ªé«˜äº†ã€‚

é‚£ä¹ˆï¼Œè¿™æ˜¯æ€ä¹ˆåšåˆ°çš„å‘¢ï¼Ÿæˆ‘ä»¬å…ˆä»å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—çš„åˆ›å»ºè¯´èµ·ã€‚

#### å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—çš„åˆ›å»º

æˆ‘ä»¬çœ‹ä¸‹queueJobçš„ä»£ç ï¼š

```ts

const queue: SchedulerJob[] = []
let flushIndex = 0

function queueJob(job: SchedulerJob) {

  // ä½¿ç”¨ Array.includes() å¹¶ä¸”ä¼ å…¥ startIndex æ¥æ£€æµ‹æ˜¯å¦æœ‰ç›¸åŒçš„job
  // åœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œ  æ˜¯å½“å‰æ­£åœ¨æ‰§è¡Œ job çš„ç´¢å¼•ï¼Œæ‰€ä»¥ ä» flushIndex å¼€å§‹æ£€ç´¢ï¼Œ
  // ä¸ä¼šå­˜åœ¨é€’å½’è§¦å‘è‡ªå·±çš„é—®é¢˜
  // å¦‚æœ job é…ç½®äº† allowRecurse å±æ€§ï¼Œæœç´¢ä¼šä» flushIndex + 1 å¼€å‘ï¼Œå®ƒå…è®¸é€’å½’è§¦å‘è‡ªå·±
  if (
    !queue.length ||
    !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )
  ) {
    if (job.id == null) {
      queue.push(job)
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job)
    }
    // æ’é˜Ÿç­‰å¾…ä»»åŠ¡æ‰§è¡Œ
    queueFlush()
  }
}
```

Vue.js å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ— queueï¼Œåœ¨ queueJob å†…éƒ¨ï¼Œä¼šé€šè¿‡ Array.includes() çš„æ–¹å¼æ£€æµ‹æ–°å¢åŠ çš„ job æ˜¯å¦å­˜åœ¨äºé˜Ÿåˆ—ä¸­ã€‚

è¿™é‡Œçš„ Array.includes å‡½æ•°ä¼šæ ¹æ®æ¡ä»¶ï¼Œä» flushIndex æˆ– flushIndex + 1 çš„ä½ç½®æ£€ç´¢

å½“ isFlushing ä¸º falseï¼Œ å³æœªå¼€å§‹æ‰§è¡Œ job çš„æ—¶å€™ï¼ŒflushIndex å§‹ç»ˆä¸º 0ï¼Œ è¿™æ—¶ åªè¦æ‰§è¡Œ 

queueJob(job) åªè¦ä¿è¯æ–°æ¥çš„ä»»åŠ¡ä¸å† queue é˜Ÿåˆ—ä¸­å³å¯ï¼›å½“ isFlushingä¸ºtrueçš„æ—¶å€™ï¼Œä¹Ÿå°±æ˜¯å¼€å‘æ‰§è¡Œä»»åŠ¡æ—¶ï¼Œ flushIndex ä¼šé€’å¢ï¼Œå¦‚æœæ­¤æ—¶åˆæœ‰æ–°çš„ä»»åŠ¡è¿›æ¥ï¼Œ é‚£ä¹ˆåªéœ€è¦å’Œ queue ä¸­æœªæ‰§è¡Œçš„ä»»åŠ¡å¯¹æ¯”å³å¯ã€‚

æœ‰äº›æ—¶å€™ï¼Œåœ¨è¿è¡ŒæŸä¸ª job çš„è¿‡ç¨‹ä¸­ï¼Œå› ä¸ºæŸç§åŸå› ï¼Œæœ‰è§¦å‘äº†è¿™ä¸ª jobï¼ŒåŒæ­¥æ‰§è¡Œäº† queueJobï¼Œ å¦‚æœæ­¤æ—¶é€šè¿‡ queue.includes(flushIndex) æ£€ç´¢ï¼Œä¼šå‘ç°è¿™ä¸ª job å·²ç»å­˜åœ¨ï¼Œä¸ä¼šæ·»åŠ åˆ° queue ä¸­ã€‚

åœ¨æŸäº›åœºæ™¯ä¸­ï¼Œ å¯èƒ½éœ€è¦é€’å½’è§¦å‘æ›´æ–°ï¼Œæ¯”å¦‚çˆ¶ç»„ä»¶æ›´æ–°æŸä¸ªå“åº”å¼æ•°æ®ï¼Œ è¿™ä¸ªæ•°æ®ä½œä¸º prop ä¼ é€’ç»™ å­ç»„ä»¶ï¼Œä»è€Œè§¦å‘å­ç»„ä»¶æ›´æ–°æ¸²æŸ“ã€‚ è€Œå­ç»„ä»¶å†…éƒ¨åˆ›å»ºäº†ä¸€ä¸ª pre ç±»å‹çš„ watcherï¼Œè§‚æµ‹è¿™ä¸ª prop å˜åŒ–ï¼Œå¹¶åœ¨å›è°ƒå‡½æ•°ä¸­ä¿®æ”¹æŸä¸ªçˆ¶ç»„ä»¶çš„å“åº”å¼æ•°æ®ï¼Œå“åº”è§¦å‘çˆ¶ç»„ä»¶çš„é‡æ–°æ¸²æŸ“ã€‚

æ­¤æ—¶ï¼Œæ•´ä¸ªè¿‡ç¨‹éƒ½å¤„äº çˆ¶ç»„ä»¶çš„å‰¯ä½œç”¨æ¸²æŸ“å‡½æ•°å¯¹åº”çš„jobä¸­ï¼Œå½“å†æ¬¡ä¿®æ”¹çˆ¶ç»„ä»¶ä¾èµ–çš„æ•°æ®æ—¶ï¼Œ è¿˜ä¼šé€šè¿‡ queueJob(job) çš„æ–¹å¼æ·»åŠ jobï¼Œä½†å¾ˆæ˜æ˜¾äºŒè€…æ˜¯åŒä¸€ä¸ª jobï¼ŒæŒ‰ä¹‹å‰çš„é€»è¾‘ï¼Œæ˜¯ä¸èƒ½æ·»åŠ åˆ°å½“å‰é˜Ÿåˆ—ä¸­çš„ã€‚

å› æ­¤ä¸ºäº†æ»¡è¶³ä¸Šè¿°è¿™ç§ç‰¹æ®Šéœ€æ±‚ï¼ŒVue.js ç»™ job è®¾è®¡äº†ä¸€ä¸ª allowRecurse å±æ€§ï¼Œå…è®¸å®ƒé€’å½’è§¦å‘è‡ªå·±ï¼Œå¹¶éœ€è¦ç”¨æˆ·ä¸ºå…¶è´Ÿè´£ï¼Œç¡®ä¿ä¸ä¼šæ— é™é€’å½’æ›´æ–°ã€‚ä¸€æ—¦é…ç½®äº†allowRecurseï¼Œ å°±ä¼šä» flushIndex + 1 çš„ä½ç½®æ£€ç´¢æ˜¯å¦æœ‰é‡å¤jobï¼Œç›¸å½“äºå…è®¸äº†è¿™ç§é€’å½’è§¦å‘è¡Œä¸ºã€‚

æˆ‘ä»¬å‰é¢åˆ†æ watcher å†…éƒ¨åˆ›å»ºçš„ jobï¼Œé€šè¿‡ queuePostRenderEffect æŠŠjobæ¨å…¥äº†å¼‚æ­¥é˜Ÿåˆ—ä¸­ï¼Œåœ¨ä¸æ¶‰åŠ suspense çš„æƒ…å†µä¸‹ï¼ŒqueuePostRenderEffect ç›¸å½“äº queuePostFlushCbï¼š

```ts

let activePostFlushCbs: SchedulerJob[] | null = null
const pendingPostFlushCbs: SchedulerJob[] = []
let postFlushIndex = 0

function queuePostFlushCb(cb: SchedulerJobs) {
  if (!isArray(cb)) {
    if (
      !activePostFlushCbs ||
      !activePostFlushCbs.includes(
        cb,
        cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
      )
    ) {
      pendingPostFlushCbs.push(cb)
    }
  } else {
    // if cb is an array, it is a component lifecycle hook which can only be
    // triggered by a job, which is already deduped in the main queue, so
    // we can skip duplicate check here to improve perf

    // å¦‚æœ cb æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œ é‚£ä¹ˆå®ƒé€šå¸¸æ˜¯ç»„ä»¶çš„å£°æ˜ä¸­æœŸå‡½æ•°ï¼Œåœ¨ flush çš„è¿‡ç¨‹ä¸­ä¼šè¢«å»é‡
    // å› æ­¤è¿™é‡Œè·³è¿‡ä¸€äº›æ£€æŸ¥å¯ä»¥æå‡ä¸€äº›æ€§èƒ½
    pendingPostFlushCbs.push(...cb)
  }
  queueFlush()
}
```

å¯ä»¥çœ‹åˆ°,è¿™é‡Œå®šä¹‰äº† 2ä¸ªå¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ— activePostFlushCbs å’Œ pendingPostFlushCbs

activePostFlushCbs æ˜¯æ­£åœ¨è¿è¡Œçš„åå¤„ç†ä»»åŠ¡é˜Ÿåˆ—ï¼ŒpendingPostFlushCbsæ˜¯å¾…è¿è¡Œçš„åå¤„ç†ä»»åŠ¡é˜Ÿåˆ—

åœ¨å¾€ pendingPostFlushCbs ä¸Šæ·»åŠ ä»»åŠ¡çš„æ—¶å€™ï¼Œä¼šåˆ¤æ–­æ˜¯å¦å·²ç»æ·»åŠ ï¼Œå¦‚æœé…ç½®äº† allowRecurse å±æ€§ï¼Œä»ç„¶è¿è¡Œé€’å½’è§¦å‘è‡ªå·±

æ— è®º queueJob è¿˜æ˜¯ queuePostFlushCbï¼Œ æœ€ç»ˆéƒ½ä¼šæ‰§è¡Œ queueFlush å‡½æ•°ï¼Œä¸‹é¢çœ‹çœ‹å®ƒçš„å®ç°ï¼š

```ts
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true
    currentFlushPromise = resolvedPromise.then(flushJobs)
  }
}
```

Vue å†…éƒ¨è¿˜ç»´æŠ¤äº†isFlushing å’Œ isFlushPending å˜é‡ï¼Œç”¨æ¥æ§åˆ¶å¼‚æ­¥ä»»åŠ¡çš„åˆ·æ–°é€»è¾‘ã€‚

åœ¨ queueFlush é¦–æ¬¡æ‰§è¡Œæ˜¯ï¼Œ isFlushing å’Œ isFlushPending éƒ½æ˜¯falseï¼Œ æ­¤æ—¶ä¼šæŠŠ isFlushPending è®¾ç½®ä¸º trueï¼Œå¹¶ä¸”é€šè¿‡ Promise.then çš„æ–¹å¼ï¼Œåœ¨ä¸‹ä¸€ä¸ª tick å»æ‰§è¡Œ flushJobs, è¿›è€Œå»æ‰§è¡Œé˜Ÿåˆ—é‡Œçš„ä»»åŠ¡ã€‚

isFlushPending çš„æ§åˆ¶æ˜¯çš„å³ä½¿å¤šæ¬¡æ‰§è¡Œ queueFlushï¼Œä¹Ÿä¸ä¼šå¤šæ¬¡å»æ‰§è¡Œ flushJobs.å› ä¸ºJavaScriptæ˜¯å•çº¿ç¨‹æ‰§è¡Œçš„ï¼Œè¿™æ ·çš„å¼‚æ­¥è®¾è®¡å¯ä»¥ä¿è¯åœ¨ä¸€ä¸ª Tick å†…ï¼Œå³ä½¿å¤šæ¬¡æ‰§è¡Œ queueFlush æˆ– queuePostFlushCb å»æ·»åŠ ä»»åŠ¡ï¼Œä¹Ÿåªæ˜¯åœ¨ å®ä»»åŠ¡æ‰§è¡Œå®Œæ¯•åçš„å¾®ä»»åŠ¡é˜¶æ®µæ‰§è¡Œä¸€æ¬¡ flushJobs

è¿™æ ·å°±èƒ½è§£é‡Šå‰é¢çš„ç¤ºä¾‹ï¼Œå³ä½¿å¤šæ¬¡ä¿®æ”¹ state.count, åªæ˜¯æŠŠ job æ·»åŠ åˆ°å¯¹åº”çš„ å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—ä¸­ï¼Œè€ŒçœŸæ­£æ‰§è¡Œä»»åŠ¡çš„ flushJobs å‡½æ•°å€¼æ‰§è¡Œä¸€æ¬¡ï¼Œå› æ­¤ watcher å¯¹åº”çš„å›è°ƒå‡½æ•°ä¹Ÿåªæ‰§è¡Œä¸€æ¬¡ã€‚

### å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—çš„æ‰§è¡Œ

åˆ›å»ºå®Œä»»åŠ¡é˜Ÿåˆ—åï¼Œæ¥ä¸‹æ¥è¦å¼‚æ­¥æ‰§è¡Œè¿™ä¸ªé˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹ flushJobs çš„å®ç°ï¼š

```ts

function flushJobs(seen?: CountMap) {
  isFlushPending = false
  isFlushing = true
  if (__DEV__) {
    seen = seen || new Map()
  }

  // ç»„ä»¶çš„æ›´æ–°è¯´ä¸‹æ˜¯å…ˆçˆ¶ç»„ä»¶åå­ç»„ä»¶
  // å¦‚æœä¸€ä¸ªç»„ä»¶åœ¨çˆ¶ç»„ä»¶æ›´æ–°è¿‡ç¨‹ä¸­è¢«å¸è½½ï¼Œé‚£ä¹ˆå®ƒè‡ªèº«çš„æ›´æ–°åº”è¯¥è¢«è·³è¿‡
  queue.sort(comparator)

  // conditional usage of checkRecursiveUpdate must be determined out of
  // try ... catch block since Rollup by default de-optimizes treeshaking
  // inside try-catch. This can leave all warning code unshaked. Although
  // they would get eventually shaken by a minifier like terser, some minifiers
  // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
  const check = __DEV__
    ? (job: SchedulerJob) => checkRecursiveUpdates(seen!, job)
    : NOOP

  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex]
      if (job && job.active !== false) {
        if (__DEV__ && check(job)) {
          continue
        }
        // console.log(`running:`, job.id)
        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)
      }
    }
  } finally {
    flushIndex = 0
    queue.length = 0

    flushPostFlushCbs(seen)

    isFlushing = false
    currentFlushPromise = null
    // pendingPostFlushCbs çš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œä¼šå†æ¬¡æ·»åŠ å¼‚æ­¥ä»»åŠ¡ï¼Œé€’å½’ flushJobs ä¼šæŠŠä»–ä»¬éƒ½æ‰§è¡Œå®Œæ¯•
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen)
    }
  }
}
```

flushJobs å‡½æ•°å¼€å±•æ‰§è¡Œçš„æ—¶å€™ï¼Œä¼šæŠŠ isFlushPending é‡ç½®ä¸º false ï¼ŒisFlushing è®¾ç½®ä¸º trueï¼Œ è¡¨ç¤ºæ­£åœ¨æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—

åœ¨éå†æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ— queue ä¹‹å‰ï¼Œä¼šå¯¹å®ƒä»¬åšä¸€æ¬¡ä»å°åˆ°å¤§çš„æ’åºï¼Œæœ‰ä»¥ä¸‹2ä¸ªåŸå› ï¼š

* æˆ‘ä»¬åˆ›å»ºç»„ä»¶çš„é¡ºåºæ˜¯ç”±çˆ¶åˆ°å­ï¼Œæ‰€æœ‰åˆ›å»ºç»„ä»¶å‰¯ä½œç”¨æ¸²æŸ“å‡½æ•°çš„é¡ºåºä¹Ÿæ˜¯å…ˆçˆ¶åå­ã€‚çˆ¶ç»„ä»¶çš„å‰¯ä½œç”¨æ¸²æŸ“å‡½æ•°çš„ effect id æ˜¯å°äº å­ç»„ä»¶çš„ï¼Œæ¯æ¬¡æ›´æ–°ç»„ä»¶ä¹Ÿæ˜¯é€šè¿‡ queueJob æŠŠeffect æ¨å…¥å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ— queue ä¸­çš„ï¼Œå› æ­¤ä¸ºäº†ä¿è¯ å…ˆæ›´æ–°çˆ¶ç»„ä»¶åœ¨æ›´æ–°å­ç»„ä»¶ï¼Œè¦å¯¹ queue è¿›è¡Œä»å°åˆ°å¤§æ’åºã€‚

* å¦‚æœä¸€ä¸ªç»„ä»¶åœ¨çˆ¶ç»„ä»¶æ›´æ–°è¿‡ç¨‹ä¸­è¢«å¸è½½ï¼Œé‚£ä¹ˆå®ƒè‡ªèº«çš„æ›´æ–°åº”è¯¥è¢«è·³è¿‡ã€‚æ‰€ä»¥ä¹Ÿåº”è¯¥ä¿è¯å…ˆæ›´æ–°çˆ¶ç»„ä»¶åœ¨æ›´æ–°å­ç»„ä»¶ï¼Œå› æ­¤è¦å¯¹ queue è¿›è¡Œä»å°åˆ°å¤§çš„æ’åºã€‚

åœ¨éå†æ‰§è¡Œ queue ä¸­çš„ä»»åŠ¡æ—¶ï¼Œä¹ŸåŒæ ·ä¼šæ£€æµ‹å¾ªç¯æ›´æ–°ã€‚éå†å®Œ queue åï¼ŒæŠŠ queue æ¸…ç©ºå¹¶å°† flushIndex é‡ç½®ä¸º 0ï¼Œæ¥ä¸‹æ¥ä¼šæ‰§è¡Œ flushPoshFlushCbs, æˆ‘ä»¬åˆ†æå®ƒçš„å®ç°ï¼š

```ts
function flushPostFlushCbs(seen?: CountMap) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)]
    pendingPostFlushCbs.length = 0

    // #1947 already has active queue, nested flushPostFlushCbs call
    // æ”¯æŒ flushPostFlushCbs çš„åµŒå¥—æ‰§è¡Œ
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped)
      return
    }

    activePostFlushCbs = deduped
    if (__DEV__) {
      seen = seen || new Map()
    }

    activePostFlushCbs.sort((a, b) => getId(a) - getId(b))

    for (
      postFlushIndex = 0;
      postFlushIndex < activePostFlushCbs.length;
      postFlushIndex++
    ) {
      if (
        __DEV__ &&
        checkRecursiveUpdates(seen!, activePostFlushCbs[postFlushIndex])
      ) {
        continue
      }
      activePostFlushCbs[postFlushIndex]()
    }
    activePostFlushCbs = null
    postFlushIndex = 0
  }
}
```

flushPostFlushCbs å‡½æ•°ä¸»è¦ç›®çš„å°±æ˜¯æ‰§è¡Œä¸€äº›åå¤„ç†ä»»åŠ¡ã€‚å®ƒæœ‰3ä¸ªä¸åŒä¹‹å¤„ï¼š

* ä¹‹å¤„ flushPostFlushCbs çš„åµŒå¥—æ‰§è¡Œï¼Œè¿™ç§æƒ…å†µä¼šå¯¼è‡´åœ¨æ‰§è¡Œ flushPostFlushCbs çš„æ—¶å€™ï¼ŒactivePostFlushCbs å¯èƒ½ä¸ä¸ºç©ºï¼Œä¸è¿‡è¿™ç§æç«¯åœºæ™¯æ¯”è¾ƒå°‘è§ã€‚

* activePostFlushCbs ä¸­çš„ä»»åŠ¡åœ¨æ‰§è¡Œæµ…éœ€è¦æŒ‰ç…§ id å¤§å°æ’åºï¼Œè¿™æ ·å¯ä»¥ä¿è¯ç»„ä»¶çš„ refs  æ•°æ®çš„æ›´æ–°ä¼˜å…ˆäºç”¨æˆ·å®šä¹‰çš„ postwatchers å›è°ƒå‡½æ•°çš„æ‰§è¡Œï¼Œç”¨æˆ·å°±å¯ä»¥åœ¨è¿™äº› watcher çš„å›è°ƒå‡½æ•°ä¸­è®¿é—®æ›´æ–°åçš„    $$refs  ä¸­çš„æ•°æ®äº†

* queue æˆ–è€… activePostFlushCbs ä¸­çš„ job åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šå†æ¬¡å‘ pendingPreFlushCbsã€pendingPostFlushCbs æˆ–è€… queu ä¸­æ·»åŠ ä¸€äº›æ–°çš„ jobã€‚å› æ­¤ä¸ºäº†ä¿è¯æ–°çš„ pendingPostFlushCbs åæ‰§è¡Œï¼Œä¸èƒ½åœ¨ flushPostFlushCbs ç»“æŸåé€’å½’ flushPostFlushCbs å‡½æ•°ã€‚

å›è°ƒ flushJobs å‡½æ•°ï¼Œæ¥ä¸‹æ¥å…ˆæŠŠ isFlushing é‡ç½®ä¸º falseï¼Œ ç„¶ååˆ¤æ–­ pendingPostFlushCbsæˆ–queue æ˜¯å¦æœ‰æ–°ä»»åŠ¡ï¼Œå¦‚æœæœ‰åˆ™é€’å½’æ‰§è¡Œ flushJobs å‡½æ•°ï¼Œè¿™æ ·ä¸€æ¥ï¼Œå°±å¯ä»¥ä¿è¯æ–°æ·»åŠ çš„è¿™äº›ä»»åŠ¡ä¹ŸæŒ‰ç…§å…ˆæ‰§è¡Œ queue,æœ€åæ‰§è¡Œ flushPostFlushCbs çš„é¡ºåºæ‰§è¡Œã€‚

## æ£€æµ‹å¾ªç¯æ›´æ–°

å‰é¢æåˆ°ï¼Œåœ¨éå†æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡çš„è¿‡ç¨‹ä¸­ï¼Œéƒ½ä¼šåœ¨éç”Ÿäº§ç¯å¢ƒä¸‹æ‰§è¡Œ checkRecursiveUpdates æ£€æµ‹æ˜¯å¦æœ‰å¾ªç¯æ›´æ–°ï¼Œå®ƒæ˜¯ç”¨æ¥è§£å†³ä»€ä¹ˆé—®é¢˜çš„å‘¢ï¼Ÿ

æˆ‘ä»¬æŠŠä¹‹å‰çš„ä¾‹å­æ”¹å†™ä¸€ä¸‹ï¼š

```ts
import { reactive, watch } from 'vue' 
const state = reactive({ count: 0 }) 
watch(() => state.count, (count, prevCount) => { 
  state.count++ 
  console.log(count) 
}) 
state.count++ 
```

å¦‚æœä½ å»è·‘è¿™ä¸ªç¤ºä¾‹ï¼Œä½ ä¼šåœ¨æ§åˆ¶å°çœ‹åˆ°è¾“å‡ºäº† 101 æ¬¡å€¼ï¼Œç„¶åæŠ¥äº†é”™è¯¯ï¼šÂ `Maximum recursive updates exceeded`Â ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬åœ¨ watcher çš„å›è°ƒå‡½æ•°é‡Œæ›´æ–°äº†æ•°æ®ï¼Œè¿™æ ·ä¼šå†ä¸€æ¬¡è¿›å…¥å›è°ƒå‡½æ•°ï¼Œå¦‚æœæˆ‘ä»¬ä¸åŠ ä»»ä½•æ§åˆ¶ï¼Œé‚£ä¹ˆå›è°ƒå‡½æ•°ä¼šä¸€ç›´æ‰§è¡Œï¼Œç›´åˆ°æŠŠå†…å­˜è€—å°½é€ æˆæµè§ˆå™¨å‡æ­»ã€‚  
ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼ŒVue.js å®ç°äº† checkRecursiveUpdates æ–¹æ³•ï¼š

```ts

const RECURSION_LIMIT = 100

function checkRecursiveUpdates(seen: CountMap, fn: SchedulerJob) {
  if (!seen.has(fn)) {
    seen.set(fn, 1)
  } else {
    const count = seen.get(fn)!
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance
      const componentName = instance && getComponentName(instance.type)
      warn(
        `Maximum recursive updates exceeded${
          componentName ? ` in component <${componentName}>` : ``
        }. ` +
          `This means you have a reactive effect that is mutating its own ` +
          `dependencies and thus recursively triggering itself. Possible sources ` +
          `include component template, render function, updated hook or ` +
          `watcher source function.`
      )
      return true
    } else {
      seen.set(fn, count + 1)
    }
  }
}
```

é€šè¿‡å‰é¢çš„ä»£ç ï¼Œæˆ‘ä»¬çŸ¥é“ flushJobs ä¸€å¼€å§‹ä¾¿åˆ›å»ºäº† seenï¼Œå®ƒæ˜¯ä¸€ä¸ª Map å¯¹è±¡ï¼Œç„¶ååœ¨ checkRecursiveUpdates çš„æ—¶å€™ä¼šæŠŠä»»åŠ¡æ·»åŠ åˆ° seen ä¸­ï¼Œè®°å½•å¼•ç”¨è®¡æ•° countï¼Œåˆå§‹å€¼ä¸º 1ï¼Œå¦‚æœ postFlushCbs å†æ¬¡æ·»åŠ äº†ç›¸åŒçš„ä»»åŠ¡ï¼Œåˆ™å¼•ç”¨è®¡æ•° count åŠ  1ï¼Œå¦‚æœ count å¤§äºæˆ‘ä»¬å®šä¹‰çš„é™åˆ¶ 100 ï¼Œåˆ™è¯´æ˜ä¸€ç›´åœ¨æ·»åŠ è¿™ä¸ªç›¸åŒçš„ä»»åŠ¡å¹¶è¶…è¿‡äº† 100 æ¬¡ã€‚é‚£ä¹ˆï¼ŒVue.js ä¼šæŠ›å‡ºè¿™ä¸ªé”™è¯¯ï¼Œå› ä¸ºåœ¨æ­£å¸¸çš„ä½¿ç”¨ä¸­ï¼Œä¸åº”è¯¥å‡ºç°è¿™ç§æƒ…å†µï¼Œè€Œæˆ‘ä»¬ä¸Šè¿°çš„é”™è¯¯ç¤ºä¾‹å°±ä¼šè§¦å‘è¿™ç§æŠ¥é”™é€»è¾‘ã€‚

## watchEffect API

watchEffect å’Œå‰é¢çš„ watch API æœ‰å“ªäº›ä¸åŒå‘¢ï¼Ÿä¸»è¦æœ‰ä¸‰ç‚¹ï¼š

1. **ä¾¦å¬çš„æºä¸åŒ**Â ã€‚watch API å¯ä»¥ä¾¦å¬ä¸€ä¸ªæˆ–å¤šä¸ªå“åº”å¼å¯¹è±¡ï¼Œä¹Ÿå¯ä»¥ä¾¦å¬ä¸€ä¸ª getter å‡½æ•°ï¼Œè€Œ watchEffect API ä¾¦å¬çš„æ˜¯ä¸€ä¸ªæ™®é€šå‡½æ•°ï¼Œåªè¦å†…éƒ¨è®¿é—®äº†å“åº”å¼å¯¹è±¡å³å¯ï¼Œè¿™ä¸ªå‡½æ•°å¹¶ä¸éœ€è¦è¿”å›å“åº”å¼å¯¹è±¡ã€‚

2. **æ²¡æœ‰å›è°ƒå‡½æ•°**Â ã€‚watchEffect API æ²¡æœ‰å›è°ƒå‡½æ•°ï¼Œå‰¯ä½œç”¨å‡½æ•°çš„å†…éƒ¨å“åº”å¼å¯¹è±¡å‘ç”Ÿå˜åŒ–åï¼Œä¼šå†æ¬¡æ‰§è¡Œè¿™ä¸ªå‰¯ä½œç”¨å‡½æ•°ã€‚

3. **ç«‹å³æ‰§è¡Œ**Â ã€‚watchEffect API åœ¨åˆ›å»ºå¥½ watcher åï¼Œä¼šç«‹åˆ»æ‰§è¡Œå®ƒçš„å‰¯ä½œç”¨å‡½æ•°ï¼Œè€Œ watch API éœ€è¦é…ç½® immediate ä¸º trueï¼Œæ‰ä¼šç«‹å³æ‰§è¡Œå›è°ƒå‡½æ•°ã€‚

watchEffect API å†…éƒ¨ä¹Ÿæ˜¯é€šè¿‡ doWatch å‡½æ•°å®ç°çš„ï¼Œç¾¡æ…•æˆ‘ä»¬æ¥çœ‹ watchEffect åœºæ™¯ä¸‹ doWatch å‡½æ•°çš„å®ç°ï¼š

```ts
export function watchEffect(
  effect: WatchEffect,
  options?: WatchOptionsBase
): WatchStopHandle {
  return doWatch(effect, null, options)
}

function doWatch(
  source: WatchSource | WatchSource[] | WatchEffect | object,
  cb: WatchCallback | null,
  { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ
): WatchStopHandle {
  
  const instance =
    getCurrentScope() === currentInstance?.scope ? currentInstance : null
  // const instance = currentInstance
  let getter: () => any
  let forceTrigger = false
  let isMultiSource = false

  if (isFunction(source)) {
      // ç»„ä»¶å·²å¸è½½ï¼Œç›´æ¥è¿”å›
      getter = () => {
        if (instance && instance.isUnmounted) {
          return
        }
        // æ‰§è¡Œæ¸…ç†å‡½æ•°
        if (cleanup) {
          cleanup()
        }
        // æ‰§è¡Œ source å‡½æ•°ï¼Œä¼ å…¥ onCleanup ä½œä¸ºå‚æ•°
        return callWithAsyncErrorHandling(
          source,
          instance,
          ErrorCodes.WATCH_CALLBACK,
          [onCleanup]
        )
      }
    }
  
  let cleanup: () => void
  
  let onCleanup: OnCleanup = (fn: () => void) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)
    }
  }

  // æ—§å€¼çš„åˆå§‹å€¼
  let oldValue: any = isMultiSource
    ? new Array((source as []).length).fill(INITIAL_WATCHER_VALUE)
    : INITIAL_WATCHER_VALUE
  // å¼‚æ­¥ä»»åŠ¡
  const job: SchedulerJob = () => {
    // effect éæ¿€æ´»ï¼Œ ç›´æ¥è¿”å›
    if (!effect.active) {
      return
    }
    
    // watchEffect
    effect.run()
  }

  // å…è®¸è§¦å‘è‡ªèº«
  job.allowRecurse = !!cb

  let scheduler: EffectScheduler
  if (flush === 'sync') {
    scheduler = job as any // the scheduler function gets called directly
  } else if (flush === 'post') {
    // è¿›å…¥ä¸€æ­¥é˜Ÿåˆ—ï¼Œç»„ä»¶æ›´æ–°åæ‰§è¡Œ
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)
  } else {
    // default: 'pre'
    job.pre = true
    if (instance) job.id = instance.uid
    scheduler = () => queueJob(job)
  }
  // åˆ›å»º effect å¯¹è±¡
  const effect = new ReactiveEffect(getter, scheduler)

  if (__DEV__) {
    effect.onTrack = onTrack
    effect.onTrigger = onTrigger
  }

  // initial run
  if (cb) {
    if (immediate) {
      job()
    } else {
      oldValue = effect.run()
    }
  } else if (flush === 'post') {
    queuePostRenderEffect(
      effect.run.bind(effect),
      instance && instance.suspense
    )
  } else {
    // æ²¡æœ‰ cbï¼Œä¸” flush ä¸ä¸º postï¼Œç«‹å³æ‰§è¡Œ
    effect.run()
  }
  // è¿”å›é”€æ¯å‡½æ•°
  const unwatch = () => {
    effect.stop()
    if (instance && instance.scope) {
      // ç§»é™¤ç»„ä»¶ effects å¯¹è¿™ä¸ª effct çš„å¼•ç”¨
      remove(instance.scope.effects!, effect)
    }
  }

  if (__SSR__ && ssrCleanup) ssrCleanup.push(unwatch)
  return unwatch
}
```

å¯ä»¥çœ‹åˆ°ï¼Œ getter å‡½æ•°å°±æ˜¯å¯¹ source å‡½æ•°çš„ç®€å•å°è£…ï¼Œå®ƒä¼šå…ˆåˆ¤æ–­ç»„ä»¶å®ä¾‹æ˜¯å¦å·²ç»é”€æ¯ï¼Œç„¶åæ¯æ¬¡æ‰§è¡Œ source å‡½æ•°å‰æ‰§è¡Œ cleanup æ¸…ç†å‡½æ•°ã€‚

watchEffect å†…éƒ¨åˆ›å»ºçš„ job å°±æ˜¯å¯¹ effect.run çš„å°è£…ï¼Œå› æ­¤å½“ watchEffect è§‚æµ‹åˆ° getter å‡½æ•°å†…éƒ¨çš„å“åº”å¼æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¼šæ‰§è¡Œä»»åŠ¡å‡½æ•° jobã€‚è€Œåœ¨ watchEffect çš„åœºæ™¯ä¸‹ï¼Œjobå‡½æ•°ä¼šæ‰§è¡Œ effect.run å‡½æ•°ï¼Œç›¸å½“äºæ‰§è¡Œäº†åŸºäº source å°è£…çš„ getter å‡½æ•°ï¼Œè¿›è€Œæ‰§è¡Œäº†å‰¯ä½œç”¨å‡½æ•° sourceã€‚

## æ³¨å†Œæ— æ•ˆå›è°ƒå‡½æ•°

æœ‰äº›æ—¶å€™ï¼ŒwatchEffect ä¼šæ³¨å†Œä¸€ä¸ªå‰¯ä½œç”¨å‡½æ•°ï¼Œåœ¨å‡½æ•°å†…éƒ¨å¯ä»¥åšä¸€äº›å¼‚æ­¥æ“ä½œï¼Œä½†æ˜¯å½“è¿™ä¸ª watcher åœæ­¢åï¼Œå¦‚æœæˆ‘ä»¬æƒ³å»å¯¹è¿™ä¸ªå¼‚æ­¥æ“ä½œåšä¸€äº›é¢å¤–äº‹æƒ…ï¼ˆæ¯”å¦‚å–æ¶ˆè¿™ä¸ªå¼‚æ­¥æ“ä½œï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ onCleanup å‚æ•°æ³¨å†Œä¸€ä¸ªæ— æ•ˆå‡½æ•°ã€‚

```ts
import {ref, watchEffect } from 'vue' 
const id = ref(0) 
watchEffect(onCleanup => { 
  // æ‰§è¡Œå¼‚æ­¥æ“ä½œ 
  const token = performAsyncOperation(id.value) 
  onCleanup(() => { 
    // å¦‚æœ id å‘ç”Ÿå˜åŒ–æˆ–è€… watcher åœæ­¢äº†ï¼Œåˆ™æ‰§è¡Œé€»è¾‘å–æ¶ˆå‰é¢çš„å¼‚æ­¥æ“ä½œ 
    token.cancel() 
  }) 
}) 
```

æˆ‘ä»¬åˆ©ç”¨ watchEffect æ³¨å†Œäº†ä¸€ä¸ªå‰¯ä½œç”¨å‡½æ•°ï¼Œå®ƒæœ‰ä¸€ä¸ª onCleanup å‚æ•°ã€‚åœ¨è¿™ä¸ªå‡½æ•°å†…éƒ¨é€šè¿‡ performAsyncOperation æ‰§è¡ŒæŸäº›å¼‚æ­¥æ“ä½œï¼Œå¹¶ä¸”è®¿é—®äº† id è¿™ä¸ªå“åº”å¼å¯¹è±¡ï¼Œç„¶åé€šè¿‡ onInvalidate æ³¨å†Œäº†ä¸€ä¸ªå›è°ƒå‡½æ•°ã€‚

å¦‚æœ id å‘ç”Ÿå˜åŒ–æˆ–è€… watcher åœæ­¢äº†ï¼Œè¿™ä¸ªå›è°ƒå‡½æ•°å°†ä¼šæ‰§è¡Œï¼Œç„¶åæ‰§è¡Œ token.cancel å–æ¶ˆä¹‹å‰çš„å¼‚æ­¥æ“ä½œã€‚

æˆ‘ä»¬æ¥å›é¡¾ onCleanup åœ¨ doWatch ä¸­çš„å®ç°ï¼š

```ts
let cleanup: () => void
let onCleanup: OnCleanup = (fn: () => void) => {
      cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)
    }
  }
```

ä¹Ÿå°±æ˜¯è¯´å½“å“åº”å¼æ•°æ®å‘ç”Ÿå˜åŒ–ï¼Œä¼šæ‰§è¡Œ cleanup æ–¹æ³•ï¼Œå½“ watcher è¢«åœæ­¢ï¼Œä¼šæ‰§è¡Œ onStop æ–¹æ³•ï¼Œè¿™ä¸¤è€…éƒ½ä¼šæ‰§è¡Œæ³¨å†Œçš„æ— æ•ˆå›è°ƒå‡½æ•° fnã€‚


